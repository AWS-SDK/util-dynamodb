class r{value;constructor(r){this.value=String("object"==typeof r&&"N"in r?r.N:r);const e="number"==typeof r.valueOf()?r.valueOf():0;if(e>Number.MAX_SAFE_INTEGER||e<Number.MIN_SAFE_INTEGER||Math.abs(e)===1/0||Number.isNaN(e))throw new Error(`NumberValue should not be initialized with an imprecise number=${e}. Use a string instead.`)}static from(e){return new r(e)}toAttributeValue(){return{N:this.toString()}}toBigInt(){const r=this.toString();return BigInt(r)}toString(){return String(this.value)}valueOf(){return this.toString()}}const e=(e,m)=>{if(void 0===e)throw new Error("Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.");if(null===e&&"object"==typeof e)return u();if(Array.isArray(e))return t(e,m);if("Set"===e?.constructor?.name)return n(e,m);if("Map"===e?.constructor?.name)return o(e,m);if("Object"===e?.constructor?.name||!e.constructor&&"object"==typeof e)return a(e,m);if(N(e))return 0===e.length&&m?.convertEmptyValues?u():i(e);if("boolean"==typeof e||"Boolean"===e?.constructor?.name)return{BOOL:e.valueOf()};if("number"==typeof e||"Number"===e?.constructor?.name)return c(e,m);if(e instanceof r)return e.toAttributeValue();if("bigint"==typeof e)return f(e);if("string"==typeof e||"String"===e?.constructor?.name)return 0===e.length&&m?.convertEmptyValues?u():s(e);if(m?.convertClassInstanceToMap&&"object"==typeof e)return a(e,m);throw new Error(`Unsupported type passed: ${e}. Pass options.convertClassInstanceToMap=true to marshall typeof object as map attribute.`)},t=(r,t)=>({L:r.filter(r=>"function"!=typeof r&&(!t?.removeUndefinedValues||t?.removeUndefinedValues&&void 0!==r)).map(r=>e(r,t))}),n=(e,t)=>{const n=t?.removeUndefinedValues?new Set([...e].filter(r=>void 0!==r)):e;if(!t?.removeUndefinedValues&&n.has(void 0))throw new Error("Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.");if(0===n.size){if(t?.convertEmptyValues)return u();throw new Error("Pass a non-empty set, or options.convertEmptyValues=true.")}const o=n.values().next().value;if(o instanceof r)return{NS:Array.from(n).map(r=>r.toString())};if("number"==typeof o)return{NS:Array.from(n).map(r=>c(r,t)).map(r=>r.N)};if("bigint"==typeof o)return{NS:Array.from(n).map(f).map(r=>r.N)};if("string"==typeof o)return{SS:Array.from(n).map(s).map(r=>r.S)};if(N(o))return{BS:Array.from(n).map(i).map(r=>r.B)};throw new Error("Only Number Set (NS), Binary Set (BS) or String Set (SS) are allowed.")},o=(r,t)=>({M:(r=>{const n={};for(const[o,a]of r)"function"==typeof a||void 0===a&&t?.removeUndefinedValues||(n[o]=e(a,t));return n})(r)}),a=(r,t)=>({M:(r=>{const n={};for(const o in r){const a=r[o];"function"==typeof a||void 0===a&&t?.removeUndefinedValues||(n[o]=e(a,t))}return n})(r)}),u=()=>({NULL:!0}),i=r=>({B:r}),s=r=>({S:r.toString()}),f=r=>({N:r.toString()}),m=r=>{throw new Error(`${r} Use NumberValue from @aws-sdk/lib-dynamodb.`)},c=(r,e)=>{if([Number.NaN,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY].map(r=>r.toString()).includes(r.toString()))throw new Error(`Special numeric value ${r.toString()} is not allowed`);return e?.allowImpreciseNumbers||(Number(r)>Number.MAX_SAFE_INTEGER?m(`Number ${r.toString()} is greater than Number.MAX_SAFE_INTEGER.`):Number(r)<Number.MIN_SAFE_INTEGER&&m(`Number ${r.toString()} is lesser than Number.MIN_SAFE_INTEGER.`)),{N:r.toString()}},N=r=>!!r?.constructor&&["ArrayBuffer","Blob","Buffer","DataView","File","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"].includes(r.constructor.name),p=(r,e)=>{for(const[t,n]of Object.entries(r))if(void 0!==n)switch(t){case"NULL":return null;case"BOOL":return Boolean(n);case"N":return l(n,e);case"B":return b(n);case"S":return S(n);case"L":return d(n,e);case"M":return y(n,e);case"NS":return new Set(n.map(r=>l(r,e)));case"BS":return new Set(n.map(b));case"SS":return new Set(n.map(S));default:throw new Error(`Unsupported type passed: ${t}`)}throw new Error(`No value defined: ${JSON.stringify(r)}`)},l=(e,t)=>{if("function"==typeof t?.wrapNumbers)return t?.wrapNumbers(e);if(t?.wrapNumbers)return r.from(e);const n=Number(e),o=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY];if((n>Number.MAX_SAFE_INTEGER||n<Number.MIN_SAFE_INTEGER)&&!o.includes(n)){if("function"!=typeof BigInt)throw new Error(`${e} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`);try{return BigInt(e)}catch(r){throw new Error(`${e} can't be converted to BigInt. Set options.wrapNumbers to get string value.`)}}return n},S=r=>r,b=r=>r,d=(r,e)=>r.map(r=>p(r,e)),y=(r,e)=>Object.entries(r).reduce((r,[t,n])=>(r[t]=p(n,e),r),{});function E(r,t){const n=e(r,t),[o,a]=Object.entries(n)[0];switch(o){case"M":case"L":return t?.convertTopLevelContainer?n:a;default:return n}}const I=(r,e)=>p(e?.convertWithoutMapWrapper?r:{M:r},e);export{r as NumberValueImpl,e as convertToAttr,p as convertToNative,E as marshall,I as unmarshall};